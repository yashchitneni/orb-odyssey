class ObjectPool {
    constructor() {\n        this.pools = new Map();\n    }\n    \n    createPool(type, createFn, resetFn, initialSize = 50) {\n        const pool = {\n            available: [],\n            active: new Set(),\n            createFn,\n            resetFn,\n            totalCreated: 0,\n            peakActive: 0\n        };\n        \n        // Pre-populate pool\n        for (let i = 0; i < initialSize; i++) {\n            const obj = createFn();\n            obj._poolType = type;\n            pool.available.push(obj);\n            pool.totalCreated++;\n        }\n        \n        this.pools.set(type, pool);\n        return pool;\n    }\n    \n    get(type) {\n        const pool = this.pools.get(type);\n        if (!pool) {\n            console.warn(`Object pool '${type}' not found`);\n            return null;\n        }\n        \n        let obj = pool.available.pop();\n        if (!obj) {\n            obj = pool.createFn();\n            obj._poolType = type;\n            pool.totalCreated++;\n        }\n        \n        pool.active.add(obj);\n        pool.peakActive = Math.max(pool.peakActive, pool.active.size);\n        \n        return obj;\n    }\n    \n    release(obj) {\n        if (!obj || !obj._poolType) return;\n        \n        const pool = this.pools.get(obj._poolType);\n        if (!pool || !pool.active.has(obj)) return;\n        \n        pool.resetFn(obj);\n        pool.active.delete(obj);\n        pool.available.push(obj);\n    }\n    \n    releaseAll(type) {\n        const pool = this.pools.get(type);\n        if (!pool) return;\n        \n        pool.active.forEach(obj => {\n            pool.resetFn(obj);\n            pool.available.push(obj);\n        });\n        pool.active.clear();\n    }\n    \n    getStats(type) {\n        const pool = this.pools.get(type);\n        if (!pool) return null;\n        \n        return {\n            type,\n            available: pool.available.length,\n            active: pool.active.size,\n            totalCreated: pool.totalCreated,\n            peakActive: pool.peakActive,\n            efficiency: pool.peakActive / pool.totalCreated\n        };\n    }\n    \n    getAllStats() {\n        const stats = {};\n        this.pools.forEach((pool, type) => {\n            stats[type] = this.getStats(type);\n        });\n        return stats;\n    }\n    \n    cleanup() {\n        this.pools.forEach((pool, type) => {\n            // Keep a minimum number of objects in pool\n            const minKeep = Math.min(10, pool.peakActive);\n            while (pool.available.length > minKeep) {\n                const obj = pool.available.pop();\n                if (obj && obj.destroy) {\n                    obj.destroy();\n                }\n            }\n        });\n    }\n}\n\n// Particle system with object pooling\nclass ParticleSystem {\n    constructor(scene, objectPool) {\n        this.scene = scene;\n        this.objectPool = objectPool;\n        this.activeParticles = new Set();\n        \n        // Create particle pools\n        this.initializePools();\n    }\n    \n    initializePools() {\n        // Trail particles\n        this.objectPool.createPool('trailParticle', \n            () => {\n                const particle = this.scene.add.circle(0, 0, 2, 0xffffff);\n                particle.setAlpha(0);\n                return particle;\n            },\n            (particle) => {\n                particle.setPosition(0, 0);\n                particle.setAlpha(0);\n                particle.setScale(1);\n                particle.setTint(0xffffff);\n                particle.setVisible(false);\n            },\n            GAME_CONSTANTS.PERFORMANCE.OBJECT_POOL_SIZES.PARTICLES\n        );\n        \n        // Explosion particles\n        this.objectPool.createPool('explosionParticle',\n            () => {\n                const particle = this.scene.add.circle(0, 0, 3, 0xffff00);\n                particle.setAlpha(0);\n                return particle;\n            },\n            (particle) => {\n                particle.setPosition(0, 0);\n                particle.setAlpha(0);\n                particle.setScale(1);\n                particle.setTint(0xffff00);\n                particle.setVisible(false);\n                particle.vx = 0;\n                particle.vy = 0;\n                particle.life = 0;\n                particle.maxLife = 1000;\n            },\n            200\n        );\n        \n        // Floating text\n        this.objectPool.createPool('floatingText',\n            () => {\n                const text = this.scene.add.text(0, 0, '', {\n                    fontSize: '16px',\n                    fill: '#ffffff'\n                });\n                text.setAlpha(0);\n                return text;\n            },\n            (text) => {\n                text.setPosition(0, 0);\n                text.setAlpha(0);\n                text.setScale(1);\n                text.setText('');\n                text.setVisible(false);\n                text.vy = 0;\n                text.life = 0;\n            },\n            GAME_CONSTANTS.PERFORMANCE.OBJECT_POOL_SIZES.FLOATING_TEXT\n        );\n    }\n    \n    createTrailParticle(x, y, color, size = 2) {\n        const particle = this.objectPool.get('trailParticle');\n        if (!particle) return null;\n        \n        particle.setPosition(x, y);\n        particle.setScale(size / 2);\n        particle.setTint(color);\n        particle.setAlpha(0.8);\n        particle.setVisible(true);\n        \n        // Fade out animation\n        this.scene.tweens.add({\n            targets: particle,\n            alpha: 0,\n            scale: 0,\n            duration: 500,\n            onComplete: () => {\n                this.objectPool.release(particle);\n            }\n        });\n        \n        return particle;\n    }\n    \n    createExplosion(x, y, count = 10, color = 0xffff00) {\n        for (let i = 0; i < count; i++) {\n            const particle = this.objectPool.get('explosionParticle');\n            if (!particle) continue;\n            \n            const angle = (i / count) * Math.PI * 2;\n            const speed = 50 + Math.random() * 100;\n            \n            particle.setPosition(x, y);\n            particle.setTint(color);\n            particle.setAlpha(1);\n            particle.setVisible(true);\n            particle.vx = Math.cos(angle) * speed;\n            particle.vy = Math.sin(angle) * speed;\n            particle.life = 0;\n            particle.maxLife = 800 + Math.random() * 400;\n            \n            this.activeParticles.add(particle);\n        }\n    }\n    \n    createFloatingText(x, y, text, color = '#ffffff', fontSize = '16px') {\n        const textObj = this.objectPool.get('floatingText');\n        if (!textObj) return null;\n        \n        textObj.setPosition(x, y);\n        textObj.setText(text);\n        textObj.setStyle({ fontSize, fill: color });\n        textObj.setAlpha(1);\n        textObj.setVisible(true);\n        textObj.vy = -30;\n        textObj.life = 0;\n        \n        this.activeParticles.add(textObj);\n        \n        return textObj;\n    }\n    \n    update(deltaTime) {\n        this.activeParticles.forEach(particle => {\n            if (particle._poolType === 'explosionParticle') {\n                particle.x += particle.vx * deltaTime / 1000;\n                particle.y += particle.vy * deltaTime / 1000;\n                particle.vy += 100 * deltaTime / 1000; // gravity\n                particle.life += deltaTime;\n                \n                const lifeRatio = particle.life / particle.maxLife;\n                particle.setAlpha(1 - lifeRatio);\n                particle.setScale(1 - lifeRatio * 0.5);\n                \n                if (particle.life >= particle.maxLife) {\n                    this.activeParticles.delete(particle);\n                    this.objectPool.release(particle);\n                }\n            } else if (particle._poolType === 'floatingText') {\n                particle.y += particle.vy * deltaTime / 1000;\n                particle.life += deltaTime;\n                \n                if (particle.life >= 1500) {\n                    const fadeTime = particle.life - 1500;\n                    particle.setAlpha(Math.max(0, 1 - fadeTime / 500));\n                    \n                    if (fadeTime >= 500) {\n                        this.activeParticles.delete(particle);\n                        this.objectPool.release(particle);\n                    }\n                }\n            }\n        });\n    }\n    \n    clear() {\n        this.activeParticles.forEach(particle => {\n            this.objectPool.release(particle);\n        });\n        this.activeParticles.clear();\n    }\n}\n\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = { ObjectPool, ParticleSystem };\n}